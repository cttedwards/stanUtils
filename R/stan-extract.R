#'
#' Extract model fits and load into stanOutput object class
#' 
#' @param model character string a name or label for the model being extracted
#' @param data logical read data into object?
#' @param mcmc logical read mcmc chains into object?
#' @param parameters character vector model parameters are extracted as separate chains for diagnostic purposes
#' @param outputs character vector model outputs are extracted as a single permuted posterior sample (i.e. with chains combined) 
#' 
#' @include stanOutput-class.R
#' @importFrom rstan extract read_stan_csv
#' @importClassesFrom rstan stanfit
#' @export
#'
stan_extract <- function(parameters = NULL, outputs = NULL, model = character(), path = "./")
{
    #current.dir <- getwd()
    #setwd(path)
	
	# check that path ends with "/"
	stopifnot(identical(unlist(strsplit(path, ""))[nchar(path)], "/"))
    
    # get file names
	inifile   <- list.files(path, pattern = "[.]ini")[grepl(model, list.files(path, pattern = "[.]ini"))]
	datfile   <- list.files(path, pattern = "[.]dat")[grepl(model, list.files(path, pattern = "[.]dat"))]
	mcmcfiles <- list.files(path, pattern = "[.]mcmc")[grepl(model, list.files(path, pattern = "[.]mcmc"))]

	# if no parameters specified get complete list from .ini file
    if (is.null(parameters)) {
        
        if (length(inifile) > 0) {
		
			if (length(inifile) > 1) {
			
				stop("model name specifies >1 model\n") 
				
			} else {
            
				permute_FALSE <- names(rstan::read_rdump(paste0(path, inifile)))
			}
            
        } else {
            
            permute_FALSE <- NULL
        }
        
    } else {
    
        permute_FALSE <- parameters
    }
    
    if (is.null(outputs)) {
        
        permute_TRUE <- NULL
            
    } else {
        
        permute_TRUE <- outputs
    }
    
    # initialise object
    dS4 <- new("stanOutput", model.name = model, parameters = permute_FALSE, outputs = permute_TRUE)
    
    # assign initial values
    dS4@inits <- rstan::read_rdump(paste0(path, inifile))
    
    # get data	
	if (length(datfile) > 0) {
	
		if (length(datfile) > 1) {
		
			stop("model name specifies >1 model\n") 
			
		} else {
		
			dS4@data <- rstan::read_rdump(paste0(path, datfile))
			
		}
		
	} else warning("no 'dat' file")
    
    # get mcmc runs		
	if (length(mcmcfiles) > 0) {
		
		# create stanfit object from mcmc outputs
		mcmc <- rstan::read_stan_csv(paste0(path, mcmcfiles))
		
		# create list object containing model outputs
		if (!is.null(permute_TRUE)) {
			
			dS4@mcmc[['outputs']] <- rstan::extract(mcmc, pars = permute_TRUE, permuted = TRUE, inc_warmup = FALSE)
		}
		
		# extract pars (with chains) for diagnostic plots
		if (!is.null(permute_FALSE)) {
			
			mcmc <- rstan::extract(mcmc, pars = permute_FALSE, permuted = FALSE, inc_warmup = FALSE)
			dimnames(mcmc)[[1]] <- 1:dim(mcmc)[1]
			if (length(mcmcfiles) > 1) dimnames(mcmc)[[2]] <- 1:dim(mcmc)[2]
			
			dS4@mcmc[['parameters']] <- lapply(permute_FALSE, function(x) mcmc[,,regexpr(x, dimnames(mcmc)[[3]]) > 0])
			names(dS4@mcmc[['parameters']]) <- permute_FALSE
		
		}
		
	} else warning("no 'mcmc' files")
    
    #setwd(current.dir)
    
    return(dS4)
}

unique_par <- function(fnames) {
    # obtain parameters from flat names in format of say alpha.1,
    # alpha.2, beta.1.1, ..., beta.3.4, --- in this case, return
    # c('alpha', 'beta')
    unique(gsub('\\..*', '', fnames))
}

get_dims_from_fnames <- function(fnames, pname) {
    # Get the dimension for a parameter from
    # the flatnames such as "alpha.1.1", ..., "alpha.3.4", the
    # format of names in the CSV files generated by Stan.
    # Currently, this function assume fnames are correctly given.
    # Args:
    #   fnames: a character of names for one (vector/array) parameter
    #   pname: the name for this vector/array parameter such as "alpha"
    #     for the above example
    
    if (missing(pname)) pname <- gsub('\\..*', '', fnames[1])
    
    if (length(fnames) == 1 && fnames == pname)
        return(integer(0)) # a scalar
    
    idxs <- sub(pname, '', fnames, fixed = TRUE)
    lp <- gregexpr('\\d+', idxs)
    
    tfun <- function(name, start, i) {
        last <- attr(start, 'match.length')[i] + start[i]
        as.integer(substr(name, start[i], last))
    }
    
    dim_len <- length(lp[[1]])
    dims <- integer(dim_len)
    for (i in 1:dim_len) {
        dimi <- mapply(tfun, idxs, lp, MoreArgs = list(i = i), USE.NAMES = FALSE)
        dims[i] <- max(dimi)
    }
    dims
}

read_stan_mcmc <- function (mcmcfiles) 
{
    
    ss_lst <- vector("list", length(mcmcfiles))
    
    for (i in seq_along(csvfiles)) {
        header <- scan(csvfiles[i], what = "character", skip = 37, nlines = 1, sep = ",", quiet = TRUE)
        vnames <- unlist(strsplit(header, ","))
        m <- matrix(scan(csvfiles[i], skip = 40, comment.char = "#", sep = ",", quiet = TRUE), ncol = length(vnames), byrow = TRUE)
        if(any(is.na(m[nrow(m),]))) m <- m[-nrow(m),]
        
        ss_lst[[i]] <- as.data.frame(m)
        colnames(ss_lst[[i]]) <- vnames
    }
    
    chains <- length(ss_lst)
    fnames <- names(ss_lst[[1]])
    n_save <- nrow(ss_lst[[1]])
    paridx <- paridx_fun(fnames)
    lp__idx <- attr(paridx, "meta")["lp__"]
    par_fnames <- c(fnames[paridx], "lp__")
    pars_oi <- unique_par(par_fnames)
    dims_oi <- lapply(pars_oi, function(i) {
        pat <- paste("^", i, "(\\.\\d+)*$", sep = "")
        i_fnames <- par_fnames[grepl(pat, par_fnames)]
        get_dims_from_fnames(i_fnames, i)
    })
    names(dims_oi) <- pars_oi
    midx <- 1:length(par_fnames)
    if (chains > 1) {
        if (!all(sapply(ss_lst[-1], function(i) identical(names(i), fnames)))) 
            stop("the CSV files do not have same parameters")
        if (!all(sapply(ss_lst[-1], function(i) identical(length(i[[1]]), n_save)))) 
            stop("the number of iterations are not the same in all CSV files")
    }
    mode <- 0L
    samples <- lapply(ss_lst, function(df) {
        ss <- df[c(paridx, lp__idx)[midx]]
        attr(ss, "sampler_params") <- df[setdiff(attr(paridx, "meta"), lp__idx)]
        ss
    })
    par_fnames <- par_fnames[midx]
    for (i in seq_along(samples)) {
        attr(samples[[i]], "adaptation_info") <- cs_lst2[[i]]$adaptation_info
        attr(samples[[i]], "args") <- list(sampler_t = cs_lst2[[i]]$sampler_t, 
                                           chain_id = cs_lst2[[i]]$chain_id)
        if (cs_lst2[[i]]$has_time) 
            attr(samples[[i]], "elapsed_time") <- get_time_from_csv(cs_lst2[[i]]$time_info)
    }
    save_warmup <- sapply(cs_lst2, function(i) i$save_warmup)
    warmup <- sapply(cs_lst2, function(i) i$warmup)
    thin <- sapply(cs_lst2, function(i) i$thin)
    iter <- sapply(cs_lst2, function(i) i$iter)
    if (!all_int_eq(warmup) || !all_int_eq(thin) || !all_int_eq(iter)) 
        stop("not all iter/warmups/thin are the same in all CSV files")
    n_kept0 <- 1 + (iter - warmup - 1)%/%thin
    warmup2 <- 0
    if (max(save_warmup) == 0L) {
        n_kept <- n_save
    }
    else if (min(save_warmup) == 1L) {
        warmup2 <- 1 + (warmup[1] - 1)%/%thin[1]
        n_kept <- n_save - warmup2
    }
    if (n_kept0[1] != n_kept) {
        warning("the number of iterations after warmup found (", 
                n_kept, ") does not match iter/warmup/thin from CSV comments (", 
                paste(n_kept0, collapse = ","), ")")
        if (n_kept < 0) {
            warmup <- warmup + n_kept
            n_kept <- 0
            mode <- 2L
        }
        n_kept0 <- n_save
        iter <- n_save
        for (i in 1:length(cs_lst2)) {
            cs_lst2[[i]]$warmup <- warmup
            cs_lst2[[i]]$iter <- iter
        }
    }
    idx_kept <- if (warmup2 == 0) 
        1:n_kept
    else -(1:warmup2)
    for (i in seq_along(samples)) {
        m <- apply(samples[[i]][idx_kept, ], 2, mean)
        attr(samples[[i]], "mean_pars") <- m[-length(m)]
        attr(samples[[i]], "mean_lp__") <- m["lp__"]
    }
    perm_lst <- lapply(1:chains, function(id) sample.int(n_kept))
    sim = list(samples = samples, iter = iter[1], thin = thin[1], 
               warmup = warmup[1], chains = chains, n_save = rep(n_save, 
                                                                 chains), warmup2 = rep(warmup2, chains), permutation = perm_lst, 
               pars_oi = pars_oi, dims_oi = dims_oi, fnames_oi = dotfnames_to_sqrfnames(par_fnames), 
               n_flatnames = length(par_fnames))
    null_dso <- new("cxxdso", sig = list(character(0)), dso_saved = FALSE, 
                    dso_filename = character(0), modulename = character(0), 
                    system = R.version$system, cxxflags = character(0), .CXXDSOMISC = new.env(parent = emptyenv()))
    null_sm <- new("stanmodel", model_name = m_name, model_code = character(0), 
                   model_cpp = list(), dso = null_dso)
    nfit <- new("stanfit", model_name = m_name, model_pars = pars_oi, 
                par_dims = dims_oi, mode = mode, sim = sim, inits = list(), 
                stan_args = cs_lst2, stanmodel = null_sm, date = sdate, 
                .MISC = new.env(parent = emptyenv()))
    return(nfit)
}

paridx_fun <- function(names) {
    # Args:
    #   names: names (character vector) such as lp__, treedepth__, stepsize__,
    #          alpha, beta.1, 
    # Returns: 
    #   The indexes in the names that are parameters other than lp__,
    #   treedepth__, or stepsize__. The vector has attribute meta
    #   with the indexes of 'treedepth__', 'lp__', and 'stepsize__'
    #   if available. 
    
    sampler_param_names <- c('lp__', 'accept_stat__', 'treedepth__', 'stepsize__', 
                             'divergent__', 'n_leapfrog__', "energy__")
    metaidx <- match(sampler_param_names, names)
    names(metaidx) <- sampler_param_names
    paridx <- setdiff(seq_along(names), metaidx)
    attr(paridx, "meta") <- metaidx[!sapply(metaidx, is.na)]
    paridx
}
